# Course 2 - Data Structures and Performance

## Introduction to the Course
* Describe the difference between an abstract data type (ADT) and its implementation.
* Work with Java's built-in classes for fundamental data structures including: String, LinkedList, TreeSet, HashSet, and HashMap.
* Implement fundamental data structures from scratch including Linked Lists and Tries (yes, we mean Tries rather than trees ... stay tuned to learn about this data structure!).
* Analyze the performance of code, using Big-O notation as well as through benchmarking experiments.
* Compare and contrast the performance of different data structures to select the most appropriate for a task.
* Write JUnit tests to ensure the correctness of your code.
* Implement several algorithms for generating and processing text.

## Working with Strings
* Describe how the Flesch Readability Score can be used to determine the readability of text
* Describe how Strings are represented in Java
* Perform basic operations with Strings in Java
* Work with the String class's built-in methods to manipulate Strings
* Write regular expressions to match String patterns
* Use regular expressions to split strings

## Efficiency Analysis and Benchmarking
* Explain why the performance of an algorithm is important
* Describe some factors that impact the performance of an algorithm
* Explain why asymptotic analysis is useful
* Calculate the big-O class of a code snippet
* Combine the runtimes of smaller code snippets to analyze the performance of more complicated code
* Compute the big-O class of code with nested loops
* Analyze the performance of selection sort
* Define worst case, average case, and best case performance and describe why each of these is used
* State and justify the asymptotic performance for linear search, binary search, selection sort, and insertion sort in the best case and in the worst case
* Describe the merge sort algorithm
* Explain the use of recursion in merge sort
* Use asymptotic analysis to compare merge sort with selection sort and with insertion sort
* State the best, worst, and average case performance for insertion sort, selection sort, merge sort, and quick sort
* Evaluate situations in which different sorting algorithms are appropriate
* Organize big-O classes according to rate of growth
* Avoid some common pitfalls in asymptotic analysis
* Explain the role of benchmarking in computer science
* Identify components of real systems which impact execution time
* Use Java timing libraries to measure execution time
* Use runtimes from a real system to reason about performance

## Interfaces, Linked Lists vs. Arrays, and Correctness
## Trees! (including Binary Search Trees and Tries)
##  Hash Maps and Edit Distance

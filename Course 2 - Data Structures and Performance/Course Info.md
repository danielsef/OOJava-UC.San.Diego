# Course 2 - Data Structures and Performance

## Introduction to the Course
* Describe the difference between an abstract data type (ADT) and its implementation.
* Work with Java's built-in classes for fundamental data structures including: String, LinkedList, TreeSet, HashSet, and HashMap.
* Implement fundamental data structures from scratch including Linked Lists and Tries (yes, we mean Tries rather than trees ... stay tuned to learn about this data structure!).
* Analyze the performance of code, using Big-O notation as well as through benchmarking experiments.
* Compare and contrast the performance of different data structures to select the most appropriate for a task.
* Write JUnit tests to ensure the correctness of your code.
* Implement several algorithms for generating and processing text.

## Working with Strings
* Describe how the Flesch Readability Score can be used to determine the readability of text
* Describe how Strings are represented in Java
* Perform basic operations with Strings in Java
* Work with the String class's built-in methods to manipulate Strings
* Write regular expressions to match String patterns
* Use regular expressions to split strings

## Efficiency Analysis and Benchmarking
* Explain why the performance of an algorithm is important
* Describe some factors that impact the performance of an algorithm
* Explain why asymptotic analysis is useful
* Calculate the big-O class of a code snippet
* Combine the runtimes of smaller code snippets to analyze the performance of more complicated code
* Compute the big-O class of code with nested loops
* Analyze the performance of selection sort
* Define worst case, average case, and best case performance and describe why each of these is used
* State and justify the asymptotic performance for linear search, binary search, selection sort, and insertion sort in the best case and in the worst case
* Describe the merge sort algorithm
* Explain the use of recursion in merge sort
* Use asymptotic analysis to compare merge sort with selection sort and with insertion sort
* State the best, worst, and average case performance for insertion sort, selection sort, merge sort, and quick sort
* Evaluate situations in which different sorting algorithms are appropriate
* Organize big-O classes according to rate of growth
* Avoid some common pitfalls in asymptotic analysis
* Explain the role of benchmarking in computer science
* Identify components of real systems which impact execution time
* Use Java timing libraries to measure execution time
* Use runtimes from a real system to reason about performance

## Interfaces, Linked Lists vs. Arrays, and Correctness
* Explain the idea of abstraction and why it is important
* Give an example of abstraction in the real world and in Java
* Describe the difference between an Abstract Data Type (ADT) and a Data Structure
* Describe and draw the structure of a LinkedList
* Describe an advantage of a LinkedList over an ArrayList
* Implement Generic classes in Java
* Throw Exceptions to indicate errors
* Implement a doubly linked list with sentinel nodes in Java
* Explain the value of having confidence in your code
* Identify ways to build confidence in code correctness
* Describe different testing practices
* Compare advantages in testing methodologies
* Write tests for a LinkedList
* Explain how Markov processes can be used to generate text
* Distinguish between training on text and generating text

## Trees! (including Binary Search Trees and Tries)
* Describe the value of trees
* Describe a Tree Data Structure
* Author a TreeNode class
* Explain the need to visit data in different orderings
* Perform and author a preorder traversal
* Perform in-order, post-order and level-order traversals
* Define a Binary Search Tree
* Identify valid Binary Search Trees
* Perform Search in a Binary Search Tree
* Insert an item into a Binary Search Tree
* Delete an item from a Binary Search Tree
* Explain the running time performance to find an item in a BST
* Compare the performance of linked lists and BSTs
* Explain what a trie data structure is
* Describe the algorithm for finding keys in and adding keys to a trie
* Compare the time to find a key in a BST to a trie
* Implement a trie data structure in Java
    
##  Hash Maps and Edit Distance
* Describe why hash tables are valuable
* Describe the role of a hash function
* Describe alternative methods for handling collisions in a Hash Table
* Identify other challenges associated with Hash Tables
* Explain the difference between a Hash Set and a Hash Map
* Describe a detailed algorithm for generating spelling suggestions for misspelled words
* Define the notion of edit distance
* Describe a na√Øve algorithm for calculating the edit distance between two strings
* Describe how pruning can be used to reduce the problem space
